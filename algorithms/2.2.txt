2.2-1
O(n^3)

2.2-2
selection sort


for j=1 to A.length-1			c1	n+1 = A.length
	buffer = min = A[j]			c2  n
	index = j					c3  n
	for i=j+1 to A.length		c4  E j=1..n: n+1-j
		if A[i]<min				c5  E j=1..n: n-j
			min=A[i]			c6  E j=1..n: tj
			index = i;			c7  E j=1..n: tj
	A[j] = min					c8  n
	A[index] = buffer			c9  n

T(n) 
= c1(n+1) + c2c3c8c9n + c4Ej=1..n (n-j+1) + c5E(n-j) + c6E(tj) + c7E(tj) =
= c1(n+1) + c2389n + c4(n + n^n - 0.5n(n+1))+c5(n^2 -0.5n(n+1))+c67Etj  =
= c1(n+1) + c2389n + 0.5c4(n + n^n)+ 0.5c5(n^2 - n)+c67Etj  

Best case: sorted
Tb(n) = T(n) - c67Etj ~ an^2 + bn+ c ~ o(n^2)

Worst case: sorted desc
Etj = E n -j 
Tw(n) ~ o(n^2)

Loop invariant:
A[1..j] always sorted and each element is smaller than any in A[1+1..n]

Initialization:
Before first iteration 0 elements sorted and unknown element smallest.
After first iteration A[1] is sorted and smallest.

Maintaince:
A[1..j] sorted and contains smallest elements
next smallest found and put into A[j+1]
A[1..j+1] contains sorted and smallest elements

Termination:
A[1..n-1] is sorted and A[n] largest -> A[1..n] sorted 


2.2-3
Worst = n
Average = n/2
0(n) always

2.2-4
Make best and worth equal so that each loop n times


