<#@ output extension=".cs" #>  
<#@ assembly name="System.Core" #>  
<#@ import namespace="System" #>  
<#@ import namespace="System.Linq" #>  
<#@ import namespace="System.Text" #>  
<#@ import namespace="System.Collections.Generic" #>  
<#@ include file="Configuration.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Text;
using System.Numerics;

namespace GreenElephant.Usafe
{

<#   
foreach(var allocator in allocators)
{
#>
namespace <#= allocator.Item1 #>
{


<#   
foreach(var structName in structs)
{
#>
  public unsafe  struct <#= structName #>Cell
  {
    public <#= structName #> element;
    public <#= structName #>Cell* next;
  }

  public unsafe  struct <#= structName #>CellCell
  {
    public <#= structName #>Cell* element;
    public <#= structName #>CellCell* next;
  }

<#   
}
#>



<#   
foreach(var structName in structs)
{
#>
        public unsafe partial interface I<#= structName #>CellAllocator
        {
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            <#= structName #>Cell* Apply(<#= allocator.Item2 #> count);
        }

		public unsafe partial interface I<#= structName #>CellCellAllocator
        {
            [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            <#= structName #>CellCell* Apply(<#= allocator.Item2 #> count);
        }

public unsafe partial class <#= structName #>CellExtensions
  {
    public <#= allocator.Item2 #> length(<#= structName #>Cell* cell)
    {
            <#= allocator.Item2 #> counter = 0;
            while (cell != null)
            {
                counter++;
                cell = (*cell).next;
            };
            return counter;
        }

        public bool equals(<#= structName #>Cell* a, <#= structName #>Cell* b)
        {
            if (a == b) return true;
            while (true)
                if (a == this.empty && b == this.empty)
                    return true;
                else if (a != this.empty && b == this.empty)
                    return false;
                else if (a == this.empty && b != this.empty)
                    return false;
                else if ((*a).element != (*b).element)
                    return false;
                else
                  { a = (*a).next; b = (*b).next; };
        }

    public <#= allocator.Item2 #> length(<#= structName #>CellCell* cell)
    {
            <#= allocator.Item2 #> counter = 0;
            while (cell != null)
            {
                counter++;
                cell = (*cell).next;
            };
            return counter;
        }

        public <#= structName #>Cell* empty
        {
            get
            {
                return null;
            }
        }

		public <#= structName #> head(<#= structName #>Cell* forwardLinkedList)
        {
            return (*forwardLinkedList).element;
        }

		
        public <#= structName #>Array toArray(<#= structName #>Cell* abc, I<#= structName #>New allocator)
        {
            var total = this.length(abc);
            var arr = allocator.Apply(total);
            var counter = 0;
            while (abc != null)
            {
                arr[counter] = (*abc).element;
                abc = (*abc).next;
                counter++;
            }

            return new <#= structName #>Array { lenght = total, index = arr };
        }

        public <#= structName #>Cell* tail(<#= structName #>Cell* forwardLinkedList)
        {
            return (*forwardLinkedList).next;
        }

        public <#= structName #>Cell* last(<#= structName #>Cell* forwardLinkedList)
        {
            while (true)
            {
                if ((*forwardLinkedList).next == null) return forwardLinkedList;
                forwardLinkedList = (*forwardLinkedList).next;
            }
        }

        public void toCells(<#= structName #>[] array, <#= structName #>Cell* memory)
        {
            <#= structName #>Cell* previous = null;

            foreach (var item in array)
            {
                (*memory) = new <#= structName #>Cell { element = item };
                if (previous != null)
                {
                    (*previous).next = memory;
                }

                previous = memory;

                memory++;
            }
        }
    }
<#   
}
#>
}
<#   
}
#>
}

