<#@ output extension=".cs" #>  
<#@ assembly name="System.Core" #>  
<#@ import namespace="System" #>  
<#@ import namespace="System.Linq" #>  
<#@ import namespace="System.Text" #>  
<#@ import namespace="System.Collections.Generic" #>  
<#@ include file="Configuration.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Text;
using System.Numerics;

namespace GreenElephant.Usafe
{

<#   
foreach(var allocator in allocators)
{
#>
namespace <#= allocator.Item1 #>
{
    public static class bits
	{
	
			        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
	 		public static <#= allocator.Item2 #> leftShiftRing(<#= allocator.Item2 #> current, <#= allocator.Item2 #> steps, <#= allocator.Item2 #> length)
			 // https://stackoverflow.com/questions/2726920/c-sharp-xor-on-two-byte-variables-will-not-compile-without-a-cast
			 => current < steps ? (<#= allocator.Item2 #>)(length - steps + current) : (<#= allocator.Item2 #>)(current - steps);
			 
	}



    public static class arrayErrorExtensions
    {
        public static void unwrap(this ArrayError err)
        {
            if (err != ArrayError.ok) System.Environment.Exit((int)err);
        }
    }

    public enum ArrayError : byte
    {
        ok,
        shit_is_longer_than_lenght,
        emptyOrNullArray
    }


<#   
foreach(var structName in structs)
{
#>

        public unsafe interface I<#= structName #>New
        {
		        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
             <#= structName #>* Apply( <#= allocator.Item2 #> count);
        }

		    public unsafe interface I<#= structName #>Delete
    {
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        void Apply(<#= structName #>* root);
    }

  	public unsafe struct <#= structName #>Array
    {
        public <#= allocator.Item2 #> lenght;
        public <#= structName #>* index;
    }

	public unsafe partial class <#= structName #>ArrayExtensions
  {
  public <#= structName #>* empty { get { return null; } }


        public ArrayError leftRotationZero_(<#= allocator.Item2 #> steps, <#= allocator.Item2 #> length, <#= structName #>* array)
        {
            if (steps > length) return ArrayError.shit_is_longer_than_lenght;
            if (array == this.empty || length <= 0) return ArrayError.emptyOrNullArray;
            _leftRotation_(steps, length, array);
            return ArrayError.ok;
        }

        /// <summary>
        /// Time - O(2 * length).
        /// Memory - O(length)
        /// </summary>
        /// <param name="steps"></param>
        /// <param name="length"></param>
        /// <param name="array"></param>
        /// <param name="allocator"></param>
        /// <param name="delete"></param>
        public void _leftRotation_(<#= allocator.Item2 #> steps, <#= allocator.Item2 #> length, <#= structName #>* array, I<#= structName #>New allocator, I<#= structName #>Delete delete)
        {
            if (steps == 0)
            {
                return;
            }
            else if (steps == 1)
            {
                _leftRotation_(steps, length, array);
                return;
            }

            var memArr = allocator.Apply(length);
            for (<#= allocator.Item2 #> j = 0; j < length; j++)
            {
                var shift = bits.leftShiftRing(j, steps, length);
                memArr[shift] = array[j];
            }

            for (<#= allocator.Item2 #> j = 0; j < length; j++)
            {
                array[j] = memArr[j];
            }

            delete.Apply(memArr);
        }



        /// <summary>
        /// Time - O(length^2).
        /// Memory - O(1)
        /// </summary>
        public void _leftRotation_(<#= allocator.Item2 #> steps, <#= allocator.Item2 #> length, <#= structName #>* array)
        {
            for (<#= allocator.Item2 #> i = 0; i < steps; i++)
            {
                <#= structName #> first = array[0];
                for (<#= allocator.Item2 #> j = 1; j < length; j++) array[j - 1] = array[j];
                array[length - 1] = first;
            }
        }

        public bool equals(<#= allocator.Item2 #> length1, <#= structName #>* array1, <#= allocator.Item2 #> length2, <#= structName #>* array2)
        {
            if (length1 != length2) return false;
            if (array1 == array2) return true;
            for (<#= allocator.Item2 #> i = 0; i < length1; i++)
            {
                if (array1[i] != array2[i]) return false;
            }

            return true;
        }
		}

<#   
}
#>
}
<#   
}
#>
}

